<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Torus Background - VIB3+ Standalone Asset</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        .overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            font-family: system-ui, sans-serif;
            z-index: 10;
            pointer-events: none;
        }
        .overlay h1 {
            font-size: 48px;
            font-weight: 200;
            letter-spacing: 8px;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }
        .overlay p {
            color: rgba(255,255,255,0.6);
            font-size: 14px;
            letter-spacing: 4px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="overlay">
        <h1>VIB3+</h1>
        <p>4D VISUALIZATION ENGINE</p>
    </div>

    <script>
        // =====================================================
        // STANDALONE VIB3+ ASSET
        // All math embedded - no external dependencies
        // =====================================================

        // Rotor4D class (4D rotation using geometric algebra)
        class Rotor4D {
            constructor(s = 1, xy = 0, xz = 0, yz = 0, xw = 0, yw = 0, zw = 0, xyzw = 0) {
                this.s = s;
                this.xy = xy;
                this.xz = xz;
                this.yz = yz;
                this.xw = xw;
                this.yw = yw;
                this.zw = zw;
                this.xyzw = xyzw;
            }

            static identity() {
                return new Rotor4D(1, 0, 0, 0, 0, 0, 0, 0);
            }

            static fromPlaneAngle(plane, angle) {
                const halfAngle = angle / 2;
                const c = Math.cos(halfAngle);
                const s = Math.sin(halfAngle);
                const r = new Rotor4D();
                r.s = c;
                switch (plane) {
                    case 'XY': r.xy = -s; break;
                    case 'XZ': r.xz = -s; break;
                    case 'YZ': r.yz = -s; break;
                    case 'XW': r.xw = -s; break;
                    case 'YW': r.yw = -s; break;
                    case 'ZW': r.zw = -s; break;
                }
                return r;
            }

            multiply(r) {
                const a = this, b = r;
                return new Rotor4D(
                    a.s*b.s - a.xy*b.xy - a.xz*b.xz - a.yz*b.yz - a.xw*b.xw - a.yw*b.yw - a.zw*b.zw - a.xyzw*b.xyzw,
                    a.s*b.xy + a.xy*b.s + a.xz*b.yz - a.yz*b.xz + a.xw*b.yw - a.yw*b.xw - a.zw*b.xyzw - a.xyzw*b.zw,
                    a.s*b.xz - a.xy*b.yz + a.xz*b.s + a.yz*b.xy + a.xw*b.zw + a.yw*b.xyzw - a.zw*b.xw + a.xyzw*b.yw,
                    a.s*b.yz + a.xy*b.xz - a.xz*b.xy + a.yz*b.s - a.xw*b.xyzw + a.yw*b.zw - a.zw*b.yw - a.xyzw*b.xw,
                    a.s*b.xw - a.xy*b.yw - a.xz*b.zw + a.yz*b.xyzw + a.xw*b.s + a.yw*b.xy + a.zw*b.xz - a.xyzw*b.yz,
                    a.s*b.yw + a.xy*b.xw - a.xz*b.xyzw - a.yz*b.zw - a.xw*b.xy + a.yw*b.s + a.zw*b.yz + a.xyzw*b.xz,
                    a.s*b.zw + a.xy*b.xyzw + a.xz*b.xw + a.yz*b.yw - a.xw*b.xz - a.yw*b.yz + a.zw*b.s - a.xyzw*b.xy,
                    a.s*b.xyzw + a.xy*b.zw - a.xz*b.yw + a.yz*b.xw + a.xw*b.yz - a.yw*b.xz + a.zw*b.xy + a.xyzw*b.s
                );
            }

            rotate(v) {
                const x = v.x, y = v.y, z = v.z, w = v.w;
                const s = this.s, xy = this.xy, xz = this.xz, yz = this.yz;
                const xw = this.xw, yw = this.yw, zw = this.zw;

                // Simplified rotation formula
                const s2 = s*s, xy2 = xy*xy, xz2 = xz*xz, yz2 = yz*yz;
                const xw2 = xw*xw, yw2 = yw*yw, zw2 = zw*zw;

                return {
                    x: x*(s2 + xy2 + xz2 - yz2 + xw2 - yw2 - zw2) +
                       2*(y*(s*xy + xz*yz + xw*yw) + z*(s*xz - xy*yz + xw*zw) + w*(s*xw - xy*yw - xz*zw)),
                    y: y*(s2 - xy2 + xz2 + yz2 - xw2 + yw2 - zw2) +
                       2*(x*(-s*xy + xz*yz + xw*yw) + z*(s*yz + xy*xz + yw*zw) + w*(s*yw + xy*xw - yz*zw)),
                    z: z*(s2 - xy2 - xz2 + yz2 - xw2 - yw2 + zw2) +
                       2*(x*(-s*xz - xy*yz + xw*zw) + y*(-s*yz + xy*xz + yw*zw) + w*(s*zw + xz*xw + yz*yw)),
                    w: w*(s2 + xy2 - xz2 - yz2 - xw2 - yw2 - zw2) +
                       2*(x*(-s*xw + xy*yw + xz*zw) + y*(-s*yw - xy*xw + yz*zw) + z*(-s*zw - xz*xw - yz*yw))
                };
            }
        }

        // Vec4 class
        class Vec4 {
            constructor(x = 0, y = 0, z = 0, w = 0) {
                this.x = x; this.y = y; this.z = z; this.w = w;
            }
        }

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Generate Clifford torus vertices
        const vertices = [];
        const R = 1.5, r = 0.6;
        const segments = 28;

        for (let i = 0; i < segments; i++) {
            for (let j = 0; j < segments; j++) {
                const u = (i / segments) * Math.PI * 2;
                const v = (j / segments) * Math.PI * 2;
                vertices.push(new Vec4(
                    R * Math.cos(u),
                    R * Math.sin(u),
                    r * Math.cos(v),
                    r * Math.sin(v)
                ));
            }
        }

        // Generate edges
        const edges = [];
        for (let i = 0; i < segments; i++) {
            for (let j = 0; j < segments; j++) {
                const curr = i * segments + j;
                const nextI = ((i + 1) % segments) * segments + j;
                const nextJ = i * segments + ((j + 1) % segments);
                edges.push([curr, nextI]);
                edges.push([curr, nextJ]);
            }
        }

        console.log('VIB3+ Torus: ' + vertices.length + ' vertices, ' + edges.length + ' edges');

        function project(v, rotor) {
            const rotated = rotor.rotate(v);
            const wDist = 4;
            const scale4D = 1 / (wDist - rotated.w * 0.3);
            const x3 = rotated.x * scale4D;
            const y3 = rotated.y * scale4D;
            const z3 = rotated.z * scale4D;
            const zDist = 5;
            const scale3D = 1 / (zDist - z3 * 0.3);
            return {
                x: canvas.width / 2 + x3 * scale3D * Math.min(canvas.width, canvas.height) * 0.25,
                y: canvas.height / 2 - y3 * scale3D * Math.min(canvas.width, canvas.height) * 0.25,
                depth: rotated.w + z3
            };
        }

        function render() {
            const t = performance.now() * 0.0001;

            // Create 6D rotation using all planes
            const r1 = Rotor4D.fromPlaneAngle('XY', t * 0.7);
            const r2 = Rotor4D.fromPlaneAngle('XW', t * 1.1);
            const r3 = Rotor4D.fromPlaneAngle('ZW', t * 0.5);
            const rotor = r1.multiply(r2).multiply(r3);

            // Fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const projected = vertices.map(v => project(v, rotor));

            // Draw edges
            edges.forEach(([i, j]) => {
                const p1 = projected[i];
                const p2 = projected[j];
                const avgDepth = (p1.depth + p2.depth) / 2;
                const opacity = Math.max(0.05, Math.min(0.5, 0.25 + avgDepth * 0.1));
                const hue = (180 + avgDepth * 40 + t * 50) % 360;

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = `hsla(${hue}, 70%, 50%, ${opacity})`;
                ctx.lineWidth = Math.max(0.5, 1.5 - avgDepth * 0.2);
                ctx.stroke();
            });

            requestAnimationFrame(render);
        }

        render();
        console.log('VIB3+ 4D Torus Background - STANDALONE VERSION');
    </script>
</body>
</html>
